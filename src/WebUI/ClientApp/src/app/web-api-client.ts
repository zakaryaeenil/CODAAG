/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.4.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IActionPsClient {
    get(): Observable<ActionPsVm>;
    create(command: CreateActionPCommand): Observable<number>;
    get2(id: number): Observable<ActionPByIdVm>;
    update(id: number, command: UpdateActionPCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getActionEval(): Observable<ActionPsWithEvalVm>;
    createEvaluation(id: number | undefined, evalId: number | undefined, command: CreateActionPEvaluationCommand): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class ActionPsClient implements IActionPsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get() : Observable<ActionPsVm> {
        let url_ = this.baseUrl + "/api/ActionPs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ActionPsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActionPsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ActionPsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionPsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionPsVm>(<any>null);
    }

    create(command: CreateActionPCommand) : Observable<number> {
        let url_ = this.baseUrl + "/api/ActionPs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number) : Observable<ActionPByIdVm> {
        let url_ = this.baseUrl + "/api/ActionPs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<ActionPByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActionPByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<ActionPByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionPByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionPByIdVm>(<any>null);
    }

    update(id: number, command: UpdateActionPCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ActionPs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ActionPs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getActionEval() : Observable<ActionPsWithEvalVm> {
        let url_ = this.baseUrl + "/api/ActionPs/eval";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionEval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionEval(<any>response_);
                } catch (e) {
                    return <Observable<ActionPsWithEvalVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActionPsWithEvalVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionEval(response: HttpResponseBase): Observable<ActionPsWithEvalVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ActionPsWithEvalVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActionPsWithEvalVm>(<any>null);
    }

    createEvaluation(id: number | undefined, evalId: number | undefined, command: CreateActionPEvaluationCommand) : Observable<string> {
        let url_ = this.baseUrl + "/api/ActionPs/evaluation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (evalId === null)
            throw new Error("The parameter 'evalId' cannot be null.");
        else if (evalId !== undefined)
            url_ += "evalId=" + encodeURIComponent("" + evalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEvaluation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEvaluation(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEvaluation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export interface IContratObjectifsClient {
    get(): Observable<ContratObjectifsVm>;
    create(command: CreateContratObjectifCommand): Observable<number>;
    get2(id: number): Observable<ContratObjectifByIdVm>;
    update(id: number, command: UpdateContratObjectifCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getStat(id: number): Observable<ContratObjectifStatByIdVm>;
}

@Injectable({
    providedIn: 'root'
})
export class ContratObjectifsClient implements IContratObjectifsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get() : Observable<ContratObjectifsVm> {
        let url_ = this.baseUrl + "/api/ContratObjectifs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ContratObjectifsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContratObjectifsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ContratObjectifsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContratObjectifsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContratObjectifsVm>(<any>null);
    }

    create(command: CreateContratObjectifCommand) : Observable<number> {
        let url_ = this.baseUrl + "/api/ContratObjectifs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number) : Observable<ContratObjectifByIdVm> {
        let url_ = this.baseUrl + "/api/ContratObjectifs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<ContratObjectifByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContratObjectifByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<ContratObjectifByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContratObjectifByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContratObjectifByIdVm>(<any>null);
    }

    update(id: number, command: UpdateContratObjectifCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ContratObjectifs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/ContratObjectifs/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getStat(id: number) : Observable<ContratObjectifStatByIdVm> {
        let url_ = this.baseUrl + "/api/ContratObjectifs/stat/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStat(<any>response_);
                } catch (e) {
                    return <Observable<ContratObjectifStatByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ContratObjectifStatByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetStat(response: HttpResponseBase): Observable<ContratObjectifStatByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContratObjectifStatByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ContratObjectifStatByIdVm>(<any>null);
    }
}

export interface IEvaluationsClient {
    get(): Observable<EvaluationsVm>;
    create(command: CreateEvaluationCommand): Observable<number>;
    get2(id: number): Observable<EvaluationByIdVm>;
    update(id: number, command: UpdateEvaluationCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getStat(id: number): Observable<GetEvaluationStatByIdVm>;
}

@Injectable({
    providedIn: 'root'
})
export class EvaluationsClient implements IEvaluationsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get() : Observable<EvaluationsVm> {
        let url_ = this.baseUrl + "/api/Evaluations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<EvaluationsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<EvaluationsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<EvaluationsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EvaluationsVm>(<any>null);
    }

    create(command: CreateEvaluationCommand) : Observable<number> {
        let url_ = this.baseUrl + "/api/Evaluations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number) : Observable<EvaluationByIdVm> {
        let url_ = this.baseUrl + "/api/Evaluations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<EvaluationByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<EvaluationByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<EvaluationByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EvaluationByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EvaluationByIdVm>(<any>null);
    }

    update(id: number, command: UpdateEvaluationCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Evaluations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Evaluations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getStat(id: number) : Observable<GetEvaluationStatByIdVm> {
        let url_ = this.baseUrl + "/api/Evaluations/stat/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStat(<any>response_);
                } catch (e) {
                    return <Observable<GetEvaluationStatByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEvaluationStatByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetStat(response: HttpResponseBase): Observable<GetEvaluationStatByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEvaluationStatByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEvaluationStatByIdVm>(<any>null);
    }
}

export interface IModelImportsClient {
    create(file: FileParameter | null | undefined): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class ModelImportsClient implements IModelImportsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(file: FileParameter | null | undefined) : Observable<boolean> {
        let url_ = this.baseUrl + "/api/ModelImports";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export interface IProjectsClient {
    get(): Observable<ProjectsVm>;
    create(command: CreateProjectCommand): Observable<number>;
    get2(id: number): Observable<ProjectByIdVm>;
    update(id: number, command: UpdateProjectCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getActionEval(): Observable<ProjectsWithEvalVm>;
    createEvaluation(id: number | undefined, evalId: number | undefined, command: CreateProjectEvaluationCommand): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class ProjectsClient implements IProjectsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get() : Observable<ProjectsVm> {
        let url_ = this.baseUrl + "/api/Projects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ProjectsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProjectsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectsVm>(<any>null);
    }

    create(command: CreateProjectCommand) : Observable<number> {
        let url_ = this.baseUrl + "/api/Projects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number) : Observable<ProjectByIdVm> {
        let url_ = this.baseUrl + "/api/Projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<ProjectByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<ProjectByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectByIdVm>(<any>null);
    }

    update(id: number, command: UpdateProjectCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Projects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getActionEval() : Observable<ProjectsWithEvalVm> {
        let url_ = this.baseUrl + "/api/Projects/eval";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActionEval(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActionEval(<any>response_);
                } catch (e) {
                    return <Observable<ProjectsWithEvalVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectsWithEvalVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetActionEval(response: HttpResponseBase): Observable<ProjectsWithEvalVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectsWithEvalVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectsWithEvalVm>(<any>null);
    }

    createEvaluation(id: number | undefined, evalId: number | undefined, command: CreateProjectEvaluationCommand) : Observable<string> {
        let url_ = this.baseUrl + "/api/Projects/evaluation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (evalId === null)
            throw new Error("The parameter 'evalId' cannot be null.");
        else if (evalId !== undefined)
            url_ += "evalId=" + encodeURIComponent("" + evalId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEvaluation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEvaluation(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEvaluation(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export interface IStatutsClient {
    get(): Observable<StatutsVm>;
    create(command: CreateStatutCommand): Observable<number>;
    get2(id: number): Observable<StatutByIdVm>;
    update(id: number, command: UpdateStatutCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getStat(id: number): Observable<StatutStatByIdVm>;
}

@Injectable({
    providedIn: 'root'
})
export class StatutsClient implements IStatutsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get() : Observable<StatutsVm> {
        let url_ = this.baseUrl + "/api/Statuts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<StatutsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatutsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StatutsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatutsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatutsVm>(<any>null);
    }

    create(command: CreateStatutCommand) : Observable<number> {
        let url_ = this.baseUrl + "/api/Statuts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number) : Observable<StatutByIdVm> {
        let url_ = this.baseUrl + "/api/Statuts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<StatutByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatutByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<StatutByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatutByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatutByIdVm>(<any>null);
    }

    update(id: number, command: UpdateStatutCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Statuts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Statuts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getStat(id: number) : Observable<StatutStatByIdVm> {
        let url_ = this.baseUrl + "/api/Statuts/stat/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStat(<any>response_);
                } catch (e) {
                    return <Observable<StatutStatByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatutStatByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetStat(response: HttpResponseBase): Observable<StatutStatByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatutStatByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatutStatByIdVm>(<any>null);
    }
}

export interface IStructuresClient {
    get(): Observable<StructuresVm>;
    create(command: CreateStructureCommand): Observable<number>;
    get2(id: number): Observable<StructureByIdVm>;
    update(id: number, command: UpdateStructureCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class StructuresClient implements IStructuresClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get() : Observable<StructuresVm> {
        let url_ = this.baseUrl + "/api/Structures";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<StructuresVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StructuresVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<StructuresVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StructuresVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StructuresVm>(<any>null);
    }

    create(command: CreateStructureCommand) : Observable<number> {
        let url_ = this.baseUrl + "/api/Structures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number) : Observable<StructureByIdVm> {
        let url_ = this.baseUrl + "/api/Structures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<StructureByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<StructureByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<StructureByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StructureByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StructureByIdVm>(<any>null);
    }

    update(id: number, command: UpdateStructureCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Structures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Structures/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITypeProjectsClient {
    get(): Observable<TypeProjectsVm>;
    create(command: CreateTypeProjectCommand): Observable<number>;
    get2(id: number): Observable<TypeProjectByIdVm>;
    update(id: number, command: UpdateTypeProjectCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    getStat(id: number): Observable<TypeProjectsStatVm>;
}

@Injectable({
    providedIn: 'root'
})
export class TypeProjectsClient implements ITypeProjectsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get() : Observable<TypeProjectsVm> {
        let url_ = this.baseUrl + "/api/TypeProjects";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TypeProjectsVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TypeProjectsVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TypeProjectsVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TypeProjectsVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TypeProjectsVm>(<any>null);
    }

    create(command: CreateTypeProjectCommand) : Observable<number> {
        let url_ = this.baseUrl + "/api/TypeProjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number) : Observable<TypeProjectByIdVm> {
        let url_ = this.baseUrl + "/api/TypeProjects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<TypeProjectByIdVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TypeProjectByIdVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<TypeProjectByIdVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TypeProjectByIdVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TypeProjectByIdVm>(<any>null);
    }

    update(id: number, command: UpdateTypeProjectCommand) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TypeProjects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number) : Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TypeProjects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getStat(id: number) : Observable<TypeProjectsStatVm> {
        let url_ = this.baseUrl + "/api/TypeProjects/stat/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStat(<any>response_);
                } catch (e) {
                    return <Observable<TypeProjectsStatVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TypeProjectsStatVm>><any>_observableThrow(response_);
        }));
    }

    protected processGetStat(response: HttpResponseBase): Observable<TypeProjectsStatVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TypeProjectsStatVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TypeProjectsStatVm>(<any>null);
    }
}

export class ActionPsVm implements IActionPsVm {
    actionPDtos?: ActionP[];

    constructor(data?: IActionPsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["actionPDtos"])) {
                this.actionPDtos = [] as any;
                for (let item of _data["actionPDtos"])
                    this.actionPDtos!.push(ActionP.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionPsVm {
        data = typeof data === 'object' ? data : {};
        let result = new ActionPsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.actionPDtos)) {
            data["actionPDtos"] = [];
            for (let item of this.actionPDtos)
                data["actionPDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IActionPsVm {
    actionPDtos?: ActionP[];
}

export abstract class AuditableEntity implements IAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        return data; 
    }
}

export interface IAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class ActionP extends AuditableEntity implements IActionP {
    id?: number;
    title?: string;
    note?: string | undefined;
    tauxR?: number | undefined;
    budgR?: number | undefined;
    startDatePrv?: Date | undefined;
    endDatePrv?: Date | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    budgPrv?: number | undefined;
    statutId?: number;
    statut?: Statut;
    projectId?: number;
    project?: Project;
    structures?: Structure[];
    evaluations?: EvaluationActionP[];

    constructor(data?: IActionP) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.tauxR = _data["tauxR"];
            this.budgR = _data["budgR"];
            this.startDatePrv = _data["startDatePrv"] ? new Date(_data["startDatePrv"].toString()) : <any>undefined;
            this.endDatePrv = _data["endDatePrv"] ? new Date(_data["endDatePrv"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.budgPrv = _data["budgPrv"];
            this.statutId = _data["statutId"];
            this.statut = _data["statut"] ? Statut.fromJS(_data["statut"]) : <any>undefined;
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            if (Array.isArray(_data["structures"])) {
                this.structures = [] as any;
                for (let item of _data["structures"])
                    this.structures!.push(Structure.fromJS(item));
            }
            if (Array.isArray(_data["evaluations"])) {
                this.evaluations = [] as any;
                for (let item of _data["evaluations"])
                    this.evaluations!.push(EvaluationActionP.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionP {
        data = typeof data === 'object' ? data : {};
        let result = new ActionP();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["note"] = this.note;
        data["tauxR"] = this.tauxR;
        data["budgR"] = this.budgR;
        data["startDatePrv"] = this.startDatePrv ? this.startDatePrv.toISOString() : <any>undefined;
        data["endDatePrv"] = this.endDatePrv ? this.endDatePrv.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["budgPrv"] = this.budgPrv;
        data["statutId"] = this.statutId;
        data["statut"] = this.statut ? this.statut.toJSON() : <any>undefined;
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        if (Array.isArray(this.structures)) {
            data["structures"] = [];
            for (let item of this.structures)
                data["structures"].push(item.toJSON());
        }
        if (Array.isArray(this.evaluations)) {
            data["evaluations"] = [];
            for (let item of this.evaluations)
                data["evaluations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IActionP extends IAuditableEntity {
    id?: number;
    title?: string;
    note?: string | undefined;
    tauxR?: number | undefined;
    budgR?: number | undefined;
    startDatePrv?: Date | undefined;
    endDatePrv?: Date | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    budgPrv?: number | undefined;
    statutId?: number;
    statut?: Statut;
    projectId?: number;
    project?: Project;
    structures?: Structure[];
    evaluations?: EvaluationActionP[];
}

export class Statut extends AuditableEntity implements IStatut {
    id?: number;
    title?: string;
    note?: string;
    color?: ColorStatut;
    contratObjectifs?: ContratObjectif[];
    actionPs?: ActionP[];
    projects?: Project[];
    evaluations?: Evaluation[];

    constructor(data?: IStatut) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.color = _data["color"];
            if (Array.isArray(_data["contratObjectifs"])) {
                this.contratObjectifs = [] as any;
                for (let item of _data["contratObjectifs"])
                    this.contratObjectifs!.push(ContratObjectif.fromJS(item));
            }
            if (Array.isArray(_data["actionPs"])) {
                this.actionPs = [] as any;
                for (let item of _data["actionPs"])
                    this.actionPs!.push(ActionP.fromJS(item));
            }
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(Project.fromJS(item));
            }
            if (Array.isArray(_data["evaluations"])) {
                this.evaluations = [] as any;
                for (let item of _data["evaluations"])
                    this.evaluations!.push(Evaluation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Statut {
        data = typeof data === 'object' ? data : {};
        let result = new Statut();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["note"] = this.note;
        data["color"] = this.color;
        if (Array.isArray(this.contratObjectifs)) {
            data["contratObjectifs"] = [];
            for (let item of this.contratObjectifs)
                data["contratObjectifs"].push(item.toJSON());
        }
        if (Array.isArray(this.actionPs)) {
            data["actionPs"] = [];
            for (let item of this.actionPs)
                data["actionPs"].push(item.toJSON());
        }
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        if (Array.isArray(this.evaluations)) {
            data["evaluations"] = [];
            for (let item of this.evaluations)
                data["evaluations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IStatut extends IAuditableEntity {
    id?: number;
    title?: string;
    note?: string;
    color?: ColorStatut;
    contratObjectifs?: ContratObjectif[];
    actionPs?: ActionP[];
    projects?: Project[];
    evaluations?: Evaluation[];
}

export enum ColorStatut {
    Primary = 0,
    Success = 1,
    Info = 2,
    Warning = 3,
    Danger = 4,
    Secondary = 5,
    Dark = 6,
    Light = 7,
    None = 8,
}

export class ContratObjectif extends AuditableEntity implements IContratObjectif {
    id?: number;
    codeCO?: string;
    title?: string;
    note?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    isActive?: boolean;
    statutId?: number | undefined;
    statut?: Statut | undefined;
    projects?: Project[];
    structures?: Structure[];

    constructor(data?: IContratObjectif) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.codeCO = _data["codeCO"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.statutId = _data["statutId"];
            this.statut = _data["statut"] ? Statut.fromJS(_data["statut"]) : <any>undefined;
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(Project.fromJS(item));
            }
            if (Array.isArray(_data["structures"])) {
                this.structures = [] as any;
                for (let item of _data["structures"])
                    this.structures!.push(Structure.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContratObjectif {
        data = typeof data === 'object' ? data : {};
        let result = new ContratObjectif();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codeCO"] = this.codeCO;
        data["title"] = this.title;
        data["note"] = this.note;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["statutId"] = this.statutId;
        data["statut"] = this.statut ? this.statut.toJSON() : <any>undefined;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        if (Array.isArray(this.structures)) {
            data["structures"] = [];
            for (let item of this.structures)
                data["structures"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IContratObjectif extends IAuditableEntity {
    id?: number;
    codeCO?: string;
    title?: string;
    note?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    isActive?: boolean;
    statutId?: number | undefined;
    statut?: Statut | undefined;
    projects?: Project[];
    structures?: Structure[];
}

export class Project extends AuditableEntity implements IProject {
    id?: number;
    codeProject?: string;
    title?: string;
    note?: string | undefined;
    startDatePrv?: Date | undefined;
    endDatePrv?: Date | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    priority?: PriorityLevel | undefined;
    tauxR?: number | undefined;
    modeReel?: string | undefined;
    isInitial?: boolean;
    statutId?: number;
    statut?: Statut;
    typeProjectId?: number;
    typeProject?: TypeProject;
    contratObjectifs?: ContratObjectif[];
    actions?: ActionP[];
    structures?: Structure[];
    evaluations?: EvaluationProject[];

    constructor(data?: IProject) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.codeProject = _data["codeProject"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.startDatePrv = _data["startDatePrv"] ? new Date(_data["startDatePrv"].toString()) : <any>undefined;
            this.endDatePrv = _data["endDatePrv"] ? new Date(_data["endDatePrv"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.priority = _data["priority"];
            this.tauxR = _data["tauxR"];
            this.modeReel = _data["modeReel"];
            this.isInitial = _data["isInitial"];
            this.statutId = _data["statutId"];
            this.statut = _data["statut"] ? Statut.fromJS(_data["statut"]) : <any>undefined;
            this.typeProjectId = _data["typeProjectId"];
            this.typeProject = _data["typeProject"] ? TypeProject.fromJS(_data["typeProject"]) : <any>undefined;
            if (Array.isArray(_data["contratObjectifs"])) {
                this.contratObjectifs = [] as any;
                for (let item of _data["contratObjectifs"])
                    this.contratObjectifs!.push(ContratObjectif.fromJS(item));
            }
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(ActionP.fromJS(item));
            }
            if (Array.isArray(_data["structures"])) {
                this.structures = [] as any;
                for (let item of _data["structures"])
                    this.structures!.push(Structure.fromJS(item));
            }
            if (Array.isArray(_data["evaluations"])) {
                this.evaluations = [] as any;
                for (let item of _data["evaluations"])
                    this.evaluations!.push(EvaluationProject.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Project {
        data = typeof data === 'object' ? data : {};
        let result = new Project();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codeProject"] = this.codeProject;
        data["title"] = this.title;
        data["note"] = this.note;
        data["startDatePrv"] = this.startDatePrv ? this.startDatePrv.toISOString() : <any>undefined;
        data["endDatePrv"] = this.endDatePrv ? this.endDatePrv.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["priority"] = this.priority;
        data["tauxR"] = this.tauxR;
        data["modeReel"] = this.modeReel;
        data["isInitial"] = this.isInitial;
        data["statutId"] = this.statutId;
        data["statut"] = this.statut ? this.statut.toJSON() : <any>undefined;
        data["typeProjectId"] = this.typeProjectId;
        data["typeProject"] = this.typeProject ? this.typeProject.toJSON() : <any>undefined;
        if (Array.isArray(this.contratObjectifs)) {
            data["contratObjectifs"] = [];
            for (let item of this.contratObjectifs)
                data["contratObjectifs"].push(item.toJSON());
        }
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        if (Array.isArray(this.structures)) {
            data["structures"] = [];
            for (let item of this.structures)
                data["structures"].push(item.toJSON());
        }
        if (Array.isArray(this.evaluations)) {
            data["evaluations"] = [];
            for (let item of this.evaluations)
                data["evaluations"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IProject extends IAuditableEntity {
    id?: number;
    codeProject?: string;
    title?: string;
    note?: string | undefined;
    startDatePrv?: Date | undefined;
    endDatePrv?: Date | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    priority?: PriorityLevel | undefined;
    tauxR?: number | undefined;
    modeReel?: string | undefined;
    isInitial?: boolean;
    statutId?: number;
    statut?: Statut;
    typeProjectId?: number;
    typeProject?: TypeProject;
    contratObjectifs?: ContratObjectif[];
    actions?: ActionP[];
    structures?: Structure[];
    evaluations?: EvaluationProject[];
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TypeProject extends AuditableEntity implements ITypeProject {
    id?: number;
    codeTP?: string;
    title?: string;
    note?: string | undefined;
    projects?: Project[];

    constructor(data?: ITypeProject) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.codeTP = _data["codeTP"];
            this.title = _data["title"];
            this.note = _data["note"];
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(Project.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeProject {
        data = typeof data === 'object' ? data : {};
        let result = new TypeProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codeTP"] = this.codeTP;
        data["title"] = this.title;
        data["note"] = this.note;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITypeProject extends IAuditableEntity {
    id?: number;
    codeTP?: string;
    title?: string;
    note?: string | undefined;
    projects?: Project[];
}

export class Structure extends AuditableEntity implements IStructure {
    id?: number;
    codeStructure?: string;
    title?: string;
    note?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    gestionnaires?: Gestionnaire[];
    parentStructure?: Structure | undefined;
    structureChildren?: Structure[];
    projects?: Project[];
    contratObjectifs?: ContratObjectif[];
    actionPs?: ActionP[];

    constructor(data?: IStructure) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.codeStructure = _data["codeStructure"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["gestionnaires"])) {
                this.gestionnaires = [] as any;
                for (let item of _data["gestionnaires"])
                    this.gestionnaires!.push(Gestionnaire.fromJS(item));
            }
            this.parentStructure = _data["parentStructure"] ? Structure.fromJS(_data["parentStructure"]) : <any>undefined;
            if (Array.isArray(_data["structureChildren"])) {
                this.structureChildren = [] as any;
                for (let item of _data["structureChildren"])
                    this.structureChildren!.push(Structure.fromJS(item));
            }
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(Project.fromJS(item));
            }
            if (Array.isArray(_data["contratObjectifs"])) {
                this.contratObjectifs = [] as any;
                for (let item of _data["contratObjectifs"])
                    this.contratObjectifs!.push(ContratObjectif.fromJS(item));
            }
            if (Array.isArray(_data["actionPs"])) {
                this.actionPs = [] as any;
                for (let item of _data["actionPs"])
                    this.actionPs!.push(ActionP.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Structure {
        data = typeof data === 'object' ? data : {};
        let result = new Structure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["codeStructure"] = this.codeStructure;
        data["title"] = this.title;
        data["note"] = this.note;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.gestionnaires)) {
            data["gestionnaires"] = [];
            for (let item of this.gestionnaires)
                data["gestionnaires"].push(item.toJSON());
        }
        data["parentStructure"] = this.parentStructure ? this.parentStructure.toJSON() : <any>undefined;
        if (Array.isArray(this.structureChildren)) {
            data["structureChildren"] = [];
            for (let item of this.structureChildren)
                data["structureChildren"].push(item.toJSON());
        }
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        if (Array.isArray(this.contratObjectifs)) {
            data["contratObjectifs"] = [];
            for (let item of this.contratObjectifs)
                data["contratObjectifs"].push(item.toJSON());
        }
        if (Array.isArray(this.actionPs)) {
            data["actionPs"] = [];
            for (let item of this.actionPs)
                data["actionPs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IStructure extends IAuditableEntity {
    id?: number;
    codeStructure?: string;
    title?: string;
    note?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    gestionnaires?: Gestionnaire[];
    parentStructure?: Structure | undefined;
    structureChildren?: Structure[];
    projects?: Project[];
    contratObjectifs?: ContratObjectif[];
    actionPs?: ActionP[];
}

export class Gestionnaire extends AuditableEntity implements IGestionnaire {
    id?: number;
    nom?: string | undefined;
    prenom?: string | undefined;
    login?: string;
    password?: string;
    code?: string;
    structureId?: number | undefined;
    structure?: Structure | undefined;

    constructor(data?: IGestionnaire) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.nom = _data["nom"];
            this.prenom = _data["prenom"];
            this.login = _data["login"];
            this.password = _data["password"];
            this.code = _data["code"];
            this.structureId = _data["structureId"];
            this.structure = _data["structure"] ? Structure.fromJS(_data["structure"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Gestionnaire {
        data = typeof data === 'object' ? data : {};
        let result = new Gestionnaire();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nom"] = this.nom;
        data["prenom"] = this.prenom;
        data["login"] = this.login;
        data["password"] = this.password;
        data["code"] = this.code;
        data["structureId"] = this.structureId;
        data["structure"] = this.structure ? this.structure.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IGestionnaire extends IAuditableEntity {
    id?: number;
    nom?: string | undefined;
    prenom?: string | undefined;
    login?: string;
    password?: string;
    code?: string;
    structureId?: number | undefined;
    structure?: Structure | undefined;
}

export class EvaluationProject extends AuditableEntity implements IEvaluationProject {
    evaluationId?: number;
    evaluation?: Evaluation;
    projectId?: number;
    project?: Project;
    tauxR?: number | undefined;

    constructor(data?: IEvaluationProject) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.evaluationId = _data["evaluationId"];
            this.evaluation = _data["evaluation"] ? Evaluation.fromJS(_data["evaluation"]) : <any>undefined;
            this.projectId = _data["projectId"];
            this.project = _data["project"] ? Project.fromJS(_data["project"]) : <any>undefined;
            this.tauxR = _data["tauxR"];
        }
    }

    static fromJS(data: any): EvaluationProject {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationProject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["evaluationId"] = this.evaluationId;
        data["evaluation"] = this.evaluation ? this.evaluation.toJSON() : <any>undefined;
        data["projectId"] = this.projectId;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["tauxR"] = this.tauxR;
        super.toJSON(data);
        return data; 
    }
}

export interface IEvaluationProject extends IAuditableEntity {
    evaluationId?: number;
    evaluation?: Evaluation;
    projectId?: number;
    project?: Project;
    tauxR?: number | undefined;
}

export class Evaluation extends AuditableEntity implements IEvaluation {
    id?: number;
    title?: string;
    note?: string;
    startDate?: Date;
    endDate?: Date;
    statutId?: number;
    statut?: Statut;
    projects?: EvaluationProject[];
    actionPs?: EvaluationActionP[];

    constructor(data?: IEvaluation) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.statutId = _data["statutId"];
            this.statut = _data["statut"] ? Statut.fromJS(_data["statut"]) : <any>undefined;
            if (Array.isArray(_data["projects"])) {
                this.projects = [] as any;
                for (let item of _data["projects"])
                    this.projects!.push(EvaluationProject.fromJS(item));
            }
            if (Array.isArray(_data["actionPs"])) {
                this.actionPs = [] as any;
                for (let item of _data["actionPs"])
                    this.actionPs!.push(EvaluationActionP.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Evaluation {
        data = typeof data === 'object' ? data : {};
        let result = new Evaluation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["note"] = this.note;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["statutId"] = this.statutId;
        data["statut"] = this.statut ? this.statut.toJSON() : <any>undefined;
        if (Array.isArray(this.projects)) {
            data["projects"] = [];
            for (let item of this.projects)
                data["projects"].push(item.toJSON());
        }
        if (Array.isArray(this.actionPs)) {
            data["actionPs"] = [];
            for (let item of this.actionPs)
                data["actionPs"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IEvaluation extends IAuditableEntity {
    id?: number;
    title?: string;
    note?: string;
    startDate?: Date;
    endDate?: Date;
    statutId?: number;
    statut?: Statut;
    projects?: EvaluationProject[];
    actionPs?: EvaluationActionP[];
}

export class EvaluationActionP extends AuditableEntity implements IEvaluationActionP {
    evaluationId?: number;
    evaluation?: Evaluation;
    actionPId?: number;
    actionP?: ActionP;
    tauxR?: number | undefined;

    constructor(data?: IEvaluationActionP) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.evaluationId = _data["evaluationId"];
            this.evaluation = _data["evaluation"] ? Evaluation.fromJS(_data["evaluation"]) : <any>undefined;
            this.actionPId = _data["actionPId"];
            this.actionP = _data["actionP"] ? ActionP.fromJS(_data["actionP"]) : <any>undefined;
            this.tauxR = _data["tauxR"];
        }
    }

    static fromJS(data: any): EvaluationActionP {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationActionP();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["evaluationId"] = this.evaluationId;
        data["evaluation"] = this.evaluation ? this.evaluation.toJSON() : <any>undefined;
        data["actionPId"] = this.actionPId;
        data["actionP"] = this.actionP ? this.actionP.toJSON() : <any>undefined;
        data["tauxR"] = this.tauxR;
        super.toJSON(data);
        return data; 
    }
}

export interface IEvaluationActionP extends IAuditableEntity {
    evaluationId?: number;
    evaluation?: Evaluation;
    actionPId?: number;
    actionP?: ActionP;
    tauxR?: number | undefined;
}

export class ActionPByIdVm implements IActionPByIdVm {
    actionPDto?: ActionP;

    constructor(data?: IActionPByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.actionPDto = _data["actionPDto"] ? ActionP.fromJS(_data["actionPDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActionPByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new ActionPByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionPDto"] = this.actionPDto ? this.actionPDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IActionPByIdVm {
    actionPDto?: ActionP;
}

export class ActionPsWithEvalVm implements IActionPsWithEvalVm {
    actionPDtos?: ActionP[];
    is?: boolean;
    evaluationDtos?: Evaluation[];

    constructor(data?: IActionPsWithEvalVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["actionPDtos"])) {
                this.actionPDtos = [] as any;
                for (let item of _data["actionPDtos"])
                    this.actionPDtos!.push(ActionP.fromJS(item));
            }
            this.is = _data["is"];
            if (Array.isArray(_data["evaluationDtos"])) {
                this.evaluationDtos = [] as any;
                for (let item of _data["evaluationDtos"])
                    this.evaluationDtos!.push(Evaluation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActionPsWithEvalVm {
        data = typeof data === 'object' ? data : {};
        let result = new ActionPsWithEvalVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.actionPDtos)) {
            data["actionPDtos"] = [];
            for (let item of this.actionPDtos)
                data["actionPDtos"].push(item.toJSON());
        }
        data["is"] = this.is;
        if (Array.isArray(this.evaluationDtos)) {
            data["evaluationDtos"] = [];
            for (let item of this.evaluationDtos)
                data["evaluationDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IActionPsWithEvalVm {
    actionPDtos?: ActionP[];
    is?: boolean;
    evaluationDtos?: Evaluation[];
}

export class CreateActionPCommand implements ICreateActionPCommand {
    title?: string;
    note?: string | undefined;
    tauxR?: number | undefined;
    budgR?: number | undefined;
    startDatePrv?: Date;
    endDatePrv?: Date;
    startDate?: Date;
    endDate?: Date;
    budgPrv?: number | undefined;
    statutId?: number | undefined;
    projectId?: number | undefined;
    structures?: number[];

    constructor(data?: ICreateActionPCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.note = _data["note"];
            this.tauxR = _data["tauxR"];
            this.budgR = _data["budgR"];
            this.startDatePrv = _data["startDatePrv"] ? new Date(_data["startDatePrv"].toString()) : <any>undefined;
            this.endDatePrv = _data["endDatePrv"] ? new Date(_data["endDatePrv"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.budgPrv = _data["budgPrv"];
            this.statutId = _data["statutId"];
            this.projectId = _data["projectId"];
            if (Array.isArray(_data["structures"])) {
                this.structures = [] as any;
                for (let item of _data["structures"])
                    this.structures!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateActionPCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActionPCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["note"] = this.note;
        data["tauxR"] = this.tauxR;
        data["budgR"] = this.budgR;
        data["startDatePrv"] = this.startDatePrv ? this.startDatePrv.toISOString() : <any>undefined;
        data["endDatePrv"] = this.endDatePrv ? this.endDatePrv.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["budgPrv"] = this.budgPrv;
        data["statutId"] = this.statutId;
        data["projectId"] = this.projectId;
        if (Array.isArray(this.structures)) {
            data["structures"] = [];
            for (let item of this.structures)
                data["structures"].push(item);
        }
        return data; 
    }
}

export interface ICreateActionPCommand {
    title?: string;
    note?: string | undefined;
    tauxR?: number | undefined;
    budgR?: number | undefined;
    startDatePrv?: Date;
    endDatePrv?: Date;
    startDate?: Date;
    endDate?: Date;
    budgPrv?: number | undefined;
    statutId?: number | undefined;
    projectId?: number | undefined;
    structures?: number[];
}

export class CreateActionPEvaluationCommand implements ICreateActionPEvaluationCommand {
    id?: number;
    evalId?: number;
    tauxR?: number;

    constructor(data?: ICreateActionPEvaluationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.evalId = _data["evalId"];
            this.tauxR = _data["tauxR"];
        }
    }

    static fromJS(data: any): CreateActionPEvaluationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActionPEvaluationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["evalId"] = this.evalId;
        data["tauxR"] = this.tauxR;
        return data; 
    }
}

export interface ICreateActionPEvaluationCommand {
    id?: number;
    evalId?: number;
    tauxR?: number;
}

export class UpdateActionPCommand implements IUpdateActionPCommand {
    id?: number;
    title?: string;
    note?: string | undefined;
    tauxR?: number | undefined;
    budgR?: number | undefined;
    startDatePrv?: Date;
    endDatePrv?: Date;
    startDate?: Date;
    endDate?: Date;
    budgPrv?: number | undefined;
    statutId?: number | undefined;
    projectId?: number | undefined;
    structures?: number[];

    constructor(data?: IUpdateActionPCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.tauxR = _data["tauxR"];
            this.budgR = _data["budgR"];
            this.startDatePrv = _data["startDatePrv"] ? new Date(_data["startDatePrv"].toString()) : <any>undefined;
            this.endDatePrv = _data["endDatePrv"] ? new Date(_data["endDatePrv"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.budgPrv = _data["budgPrv"];
            this.statutId = _data["statutId"];
            this.projectId = _data["projectId"];
            if (Array.isArray(_data["structures"])) {
                this.structures = [] as any;
                for (let item of _data["structures"])
                    this.structures!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateActionPCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateActionPCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["note"] = this.note;
        data["tauxR"] = this.tauxR;
        data["budgR"] = this.budgR;
        data["startDatePrv"] = this.startDatePrv ? this.startDatePrv.toISOString() : <any>undefined;
        data["endDatePrv"] = this.endDatePrv ? this.endDatePrv.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["budgPrv"] = this.budgPrv;
        data["statutId"] = this.statutId;
        data["projectId"] = this.projectId;
        if (Array.isArray(this.structures)) {
            data["structures"] = [];
            for (let item of this.structures)
                data["structures"].push(item);
        }
        return data; 
    }
}

export interface IUpdateActionPCommand {
    id?: number;
    title?: string;
    note?: string | undefined;
    tauxR?: number | undefined;
    budgR?: number | undefined;
    startDatePrv?: Date;
    endDatePrv?: Date;
    startDate?: Date;
    endDate?: Date;
    budgPrv?: number | undefined;
    statutId?: number | undefined;
    projectId?: number | undefined;
    structures?: number[];
}

export class ContratObjectifsVm implements IContratObjectifsVm {
    contratObjectifDtos?: ContratObjectif[];

    constructor(data?: IContratObjectifsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["contratObjectifDtos"])) {
                this.contratObjectifDtos = [] as any;
                for (let item of _data["contratObjectifDtos"])
                    this.contratObjectifDtos!.push(ContratObjectif.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ContratObjectifsVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContratObjectifsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.contratObjectifDtos)) {
            data["contratObjectifDtos"] = [];
            for (let item of this.contratObjectifDtos)
                data["contratObjectifDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContratObjectifsVm {
    contratObjectifDtos?: ContratObjectif[];
}

export class ContratObjectifByIdVm implements IContratObjectifByIdVm {
    contratObjectifDto?: ContratObjectif;

    constructor(data?: IContratObjectifByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contratObjectifDto = _data["contratObjectifDto"] ? ContratObjectif.fromJS(_data["contratObjectifDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContratObjectifByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContratObjectifByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contratObjectifDto"] = this.contratObjectifDto ? this.contratObjectifDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContratObjectifByIdVm {
    contratObjectifDto?: ContratObjectif;
}

export class CreateContratObjectifCommand implements ICreateContratObjectifCommand {
    title?: string | undefined;
    comment?: string | undefined;
    startD?: Date;
    endD?: Date;
    isActive?: boolean;
    statut?: number | undefined;

    constructor(data?: ICreateContratObjectifCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.comment = _data["comment"];
            this.startD = _data["startD"] ? new Date(_data["startD"].toString()) : <any>undefined;
            this.endD = _data["endD"] ? new Date(_data["endD"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.statut = _data["statut"];
        }
    }

    static fromJS(data: any): CreateContratObjectifCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContratObjectifCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["comment"] = this.comment;
        data["startD"] = this.startD ? this.startD.toISOString() : <any>undefined;
        data["endD"] = this.endD ? this.endD.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["statut"] = this.statut;
        return data; 
    }
}

export interface ICreateContratObjectifCommand {
    title?: string | undefined;
    comment?: string | undefined;
    startD?: Date;
    endD?: Date;
    isActive?: boolean;
    statut?: number | undefined;
}

export class UpdateContratObjectifCommand implements IUpdateContratObjectifCommand {
    id?: number;
    title?: string | undefined;
    comment?: string | undefined;
    startD?: Date;
    endD?: Date;
    isActive?: boolean;
    statut?: number | undefined;

    constructor(data?: IUpdateContratObjectifCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.comment = _data["comment"];
            this.startD = _data["startD"] ? new Date(_data["startD"].toString()) : <any>undefined;
            this.endD = _data["endD"] ? new Date(_data["endD"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.statut = _data["statut"];
        }
    }

    static fromJS(data: any): UpdateContratObjectifCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContratObjectifCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["comment"] = this.comment;
        data["startD"] = this.startD ? this.startD.toISOString() : <any>undefined;
        data["endD"] = this.endD ? this.endD.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["statut"] = this.statut;
        return data; 
    }
}

export interface IUpdateContratObjectifCommand {
    id?: number;
    title?: string | undefined;
    comment?: string | undefined;
    startD?: Date;
    endD?: Date;
    isActive?: boolean;
    statut?: number | undefined;
}

export class ContratObjectifStatByIdVm implements IContratObjectifStatByIdVm {
    contratObjectifDto?: ContratObjectifStat;

    constructor(data?: IContratObjectifStatByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contratObjectifDto = _data["contratObjectifDto"] ? ContratObjectifStat.fromJS(_data["contratObjectifDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContratObjectifStatByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new ContratObjectifStatByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contratObjectifDto"] = this.contratObjectifDto ? this.contratObjectifDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContratObjectifStatByIdVm {
    contratObjectifDto?: ContratObjectifStat;
}

export class ContratObjectifStat implements IContratObjectifStat {
    projectsCount?: number;
    diffProjectsCount?: number;
    structuresCount?: number;
    diffStructuresCount?: number;

    constructor(data?: IContratObjectifStat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectsCount = _data["projectsCount"];
            this.diffProjectsCount = _data["diffProjectsCount"];
            this.structuresCount = _data["structuresCount"];
            this.diffStructuresCount = _data["diffStructuresCount"];
        }
    }

    static fromJS(data: any): ContratObjectifStat {
        data = typeof data === 'object' ? data : {};
        let result = new ContratObjectifStat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectsCount"] = this.projectsCount;
        data["diffProjectsCount"] = this.diffProjectsCount;
        data["structuresCount"] = this.structuresCount;
        data["diffStructuresCount"] = this.diffStructuresCount;
        return data; 
    }
}

export interface IContratObjectifStat {
    projectsCount?: number;
    diffProjectsCount?: number;
    structuresCount?: number;
    diffStructuresCount?: number;
}

export class EvaluationsVm implements IEvaluationsVm {
    evaluationDtos?: Evaluation[];

    constructor(data?: IEvaluationsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["evaluationDtos"])) {
                this.evaluationDtos = [] as any;
                for (let item of _data["evaluationDtos"])
                    this.evaluationDtos!.push(Evaluation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EvaluationsVm {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.evaluationDtos)) {
            data["evaluationDtos"] = [];
            for (let item of this.evaluationDtos)
                data["evaluationDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEvaluationsVm {
    evaluationDtos?: Evaluation[];
}

export class EvaluationByIdVm implements IEvaluationByIdVm {
    evaluationDto?: Evaluation;

    constructor(data?: IEvaluationByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.evaluationDto = _data["evaluationDto"] ? Evaluation.fromJS(_data["evaluationDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EvaluationByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["evaluationDto"] = this.evaluationDto ? this.evaluationDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEvaluationByIdVm {
    evaluationDto?: Evaluation;
}

export class CreateEvaluationCommand implements ICreateEvaluationCommand {
    startD?: Date;
    endD?: Date;
    title?: string | undefined;
    comment?: string | undefined;
    statut?: number | undefined;

    constructor(data?: ICreateEvaluationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startD = _data["startD"] ? new Date(_data["startD"].toString()) : <any>undefined;
            this.endD = _data["endD"] ? new Date(_data["endD"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.comment = _data["comment"];
            this.statut = _data["statut"];
        }
    }

    static fromJS(data: any): CreateEvaluationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEvaluationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startD"] = this.startD ? this.startD.toISOString() : <any>undefined;
        data["endD"] = this.endD ? this.endD.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["comment"] = this.comment;
        data["statut"] = this.statut;
        return data; 
    }
}

export interface ICreateEvaluationCommand {
    startD?: Date;
    endD?: Date;
    title?: string | undefined;
    comment?: string | undefined;
    statut?: number | undefined;
}

export class UpdateEvaluationCommand implements IUpdateEvaluationCommand {
    id?: number;
    startD?: Date;
    endD?: Date;
    title?: string | undefined;
    comment?: string | undefined;
    statut?: number | undefined;

    constructor(data?: IUpdateEvaluationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startD = _data["startD"] ? new Date(_data["startD"].toString()) : <any>undefined;
            this.endD = _data["endD"] ? new Date(_data["endD"].toString()) : <any>undefined;
            this.title = _data["title"];
            this.comment = _data["comment"];
            this.statut = _data["statut"];
        }
    }

    static fromJS(data: any): UpdateEvaluationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEvaluationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startD"] = this.startD ? this.startD.toISOString() : <any>undefined;
        data["endD"] = this.endD ? this.endD.toISOString() : <any>undefined;
        data["title"] = this.title;
        data["comment"] = this.comment;
        data["statut"] = this.statut;
        return data; 
    }
}

export interface IUpdateEvaluationCommand {
    id?: number;
    startD?: Date;
    endD?: Date;
    title?: string | undefined;
    comment?: string | undefined;
    statut?: number | undefined;
}

export class GetEvaluationStatByIdVm implements IGetEvaluationStatByIdVm {
    evaluationStat?: EvaluationStat;

    constructor(data?: IGetEvaluationStatByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.evaluationStat = _data["evaluationStat"] ? EvaluationStat.fromJS(_data["evaluationStat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEvaluationStatByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new GetEvaluationStatByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["evaluationStat"] = this.evaluationStat ? this.evaluationStat.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEvaluationStatByIdVm {
    evaluationStat?: EvaluationStat;
}

export class EvaluationStat implements IEvaluationStat {
    projectsCount?: number;
    diffProjectsCount?: number;
    actionPsCount?: number;
    diffActionPsCount?: number;

    constructor(data?: IEvaluationStat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectsCount = _data["projectsCount"];
            this.diffProjectsCount = _data["diffProjectsCount"];
            this.actionPsCount = _data["actionPsCount"];
            this.diffActionPsCount = _data["diffActionPsCount"];
        }
    }

    static fromJS(data: any): EvaluationStat {
        data = typeof data === 'object' ? data : {};
        let result = new EvaluationStat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectsCount"] = this.projectsCount;
        data["diffProjectsCount"] = this.diffProjectsCount;
        data["actionPsCount"] = this.actionPsCount;
        data["diffActionPsCount"] = this.diffActionPsCount;
        return data; 
    }
}

export interface IEvaluationStat {
    projectsCount?: number;
    diffProjectsCount?: number;
    actionPsCount?: number;
    diffActionPsCount?: number;
}

export class ProjectsVm implements IProjectsVm {
    projectDtos?: Project[];

    constructor(data?: IProjectsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projectDtos"])) {
                this.projectDtos = [] as any;
                for (let item of _data["projectDtos"])
                    this.projectDtos!.push(Project.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectsVm {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projectDtos)) {
            data["projectDtos"] = [];
            for (let item of this.projectDtos)
                data["projectDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProjectsVm {
    projectDtos?: Project[];
}

export class ProjectByIdVm implements IProjectByIdVm {
    projectDto?: Project;

    constructor(data?: IProjectByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectDto = _data["projectDto"] ? Project.fromJS(_data["projectDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProjectByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectDto"] = this.projectDto ? this.projectDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProjectByIdVm {
    projectDto?: Project;
}

export class ProjectsWithEvalVm implements IProjectsWithEvalVm {
    projectsDtos?: Project[];
    is?: boolean;
    evaluationDtos?: Evaluation[];

    constructor(data?: IProjectsWithEvalVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["projectsDtos"])) {
                this.projectsDtos = [] as any;
                for (let item of _data["projectsDtos"])
                    this.projectsDtos!.push(Project.fromJS(item));
            }
            this.is = _data["is"];
            if (Array.isArray(_data["evaluationDtos"])) {
                this.evaluationDtos = [] as any;
                for (let item of _data["evaluationDtos"])
                    this.evaluationDtos!.push(Evaluation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProjectsWithEvalVm {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectsWithEvalVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.projectsDtos)) {
            data["projectsDtos"] = [];
            for (let item of this.projectsDtos)
                data["projectsDtos"].push(item.toJSON());
        }
        data["is"] = this.is;
        if (Array.isArray(this.evaluationDtos)) {
            data["evaluationDtos"] = [];
            for (let item of this.evaluationDtos)
                data["evaluationDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProjectsWithEvalVm {
    projectsDtos?: Project[];
    is?: boolean;
    evaluationDtos?: Evaluation[];
}

export class CreateProjectCommand implements ICreateProjectCommand {
    title?: string | undefined;
    note?: string | undefined;
    startDatePrv?: Date | undefined;
    endDatePrv?: Date | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    priority?: PriorityLevel;
    tauxR?: number | undefined;
    modeReel?: string | undefined;
    isInitial?: boolean;
    statut?: number | undefined;
    typeProjectId?: number | undefined;
    contratObjectifs?: number[];
    structures?: number[];

    constructor(data?: ICreateProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.note = _data["note"];
            this.startDatePrv = _data["startDatePrv"] ? new Date(_data["startDatePrv"].toString()) : <any>undefined;
            this.endDatePrv = _data["endDatePrv"] ? new Date(_data["endDatePrv"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.priority = _data["priority"];
            this.tauxR = _data["tauxR"];
            this.modeReel = _data["modeReel"];
            this.isInitial = _data["isInitial"];
            this.statut = _data["statut"];
            this.typeProjectId = _data["typeProjectId"];
            if (Array.isArray(_data["contratObjectifs"])) {
                this.contratObjectifs = [] as any;
                for (let item of _data["contratObjectifs"])
                    this.contratObjectifs!.push(item);
            }
            if (Array.isArray(_data["structures"])) {
                this.structures = [] as any;
                for (let item of _data["structures"])
                    this.structures!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["note"] = this.note;
        data["startDatePrv"] = this.startDatePrv ? this.startDatePrv.toISOString() : <any>undefined;
        data["endDatePrv"] = this.endDatePrv ? this.endDatePrv.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["priority"] = this.priority;
        data["tauxR"] = this.tauxR;
        data["modeReel"] = this.modeReel;
        data["isInitial"] = this.isInitial;
        data["statut"] = this.statut;
        data["typeProjectId"] = this.typeProjectId;
        if (Array.isArray(this.contratObjectifs)) {
            data["contratObjectifs"] = [];
            for (let item of this.contratObjectifs)
                data["contratObjectifs"].push(item);
        }
        if (Array.isArray(this.structures)) {
            data["structures"] = [];
            for (let item of this.structures)
                data["structures"].push(item);
        }
        return data; 
    }
}

export interface ICreateProjectCommand {
    title?: string | undefined;
    note?: string | undefined;
    startDatePrv?: Date | undefined;
    endDatePrv?: Date | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    priority?: PriorityLevel;
    tauxR?: number | undefined;
    modeReel?: string | undefined;
    isInitial?: boolean;
    statut?: number | undefined;
    typeProjectId?: number | undefined;
    contratObjectifs?: number[];
    structures?: number[];
}

export class CreateProjectEvaluationCommand implements ICreateProjectEvaluationCommand {
    id?: number;
    evalId?: number;
    tauxR?: number;

    constructor(data?: ICreateProjectEvaluationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.evalId = _data["evalId"];
            this.tauxR = _data["tauxR"];
        }
    }

    static fromJS(data: any): CreateProjectEvaluationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProjectEvaluationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["evalId"] = this.evalId;
        data["tauxR"] = this.tauxR;
        return data; 
    }
}

export interface ICreateProjectEvaluationCommand {
    id?: number;
    evalId?: number;
    tauxR?: number;
}

export class UpdateProjectCommand implements IUpdateProjectCommand {
    id?: number;
    title?: string | undefined;
    note?: string | undefined;
    startDatePrv?: Date | undefined;
    endDatePrv?: Date | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    priority?: PriorityLevel;
    tauxR?: number | undefined;
    modeReel?: string | undefined;
    isInitial?: boolean;
    statut?: number | undefined;
    typeProjectId?: number | undefined;
    contratObjectifs?: number[];
    structures?: number[];

    constructor(data?: IUpdateProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.note = _data["note"];
            this.startDatePrv = _data["startDatePrv"] ? new Date(_data["startDatePrv"].toString()) : <any>undefined;
            this.endDatePrv = _data["endDatePrv"] ? new Date(_data["endDatePrv"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.priority = _data["priority"];
            this.tauxR = _data["tauxR"];
            this.modeReel = _data["modeReel"];
            this.isInitial = _data["isInitial"];
            this.statut = _data["statut"];
            this.typeProjectId = _data["typeProjectId"];
            if (Array.isArray(_data["contratObjectifs"])) {
                this.contratObjectifs = [] as any;
                for (let item of _data["contratObjectifs"])
                    this.contratObjectifs!.push(item);
            }
            if (Array.isArray(_data["structures"])) {
                this.structures = [] as any;
                for (let item of _data["structures"])
                    this.structures!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["note"] = this.note;
        data["startDatePrv"] = this.startDatePrv ? this.startDatePrv.toISOString() : <any>undefined;
        data["endDatePrv"] = this.endDatePrv ? this.endDatePrv.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["priority"] = this.priority;
        data["tauxR"] = this.tauxR;
        data["modeReel"] = this.modeReel;
        data["isInitial"] = this.isInitial;
        data["statut"] = this.statut;
        data["typeProjectId"] = this.typeProjectId;
        if (Array.isArray(this.contratObjectifs)) {
            data["contratObjectifs"] = [];
            for (let item of this.contratObjectifs)
                data["contratObjectifs"].push(item);
        }
        if (Array.isArray(this.structures)) {
            data["structures"] = [];
            for (let item of this.structures)
                data["structures"].push(item);
        }
        return data; 
    }
}

export interface IUpdateProjectCommand {
    id?: number;
    title?: string | undefined;
    note?: string | undefined;
    startDatePrv?: Date | undefined;
    endDatePrv?: Date | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    priority?: PriorityLevel;
    tauxR?: number | undefined;
    modeReel?: string | undefined;
    isInitial?: boolean;
    statut?: number | undefined;
    typeProjectId?: number | undefined;
    contratObjectifs?: number[];
    structures?: number[];
}

export class StatutsVm implements IStatutsVm {
    statutDtos?: Statut[];

    constructor(data?: IStatutsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["statutDtos"])) {
                this.statutDtos = [] as any;
                for (let item of _data["statutDtos"])
                    this.statutDtos!.push(Statut.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatutsVm {
        data = typeof data === 'object' ? data : {};
        let result = new StatutsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.statutDtos)) {
            data["statutDtos"] = [];
            for (let item of this.statutDtos)
                data["statutDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStatutsVm {
    statutDtos?: Statut[];
}

export class StatutByIdVm implements IStatutByIdVm {
    statutDto?: Statut;

    constructor(data?: IStatutByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statutDto = _data["statutDto"] ? Statut.fromJS(_data["statutDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StatutByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new StatutByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statutDto"] = this.statutDto ? this.statutDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStatutByIdVm {
    statutDto?: Statut;
}

export class CreateStatutCommand implements ICreateStatutCommand {
    title?: string | undefined;
    comment?: string | undefined;
    color?: ColorStatut;

    constructor(data?: ICreateStatutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.comment = _data["comment"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): CreateStatutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStatutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["comment"] = this.comment;
        data["color"] = this.color;
        return data; 
    }
}

export interface ICreateStatutCommand {
    title?: string | undefined;
    comment?: string | undefined;
    color?: ColorStatut;
}

export class UpdateStatutCommand implements IUpdateStatutCommand {
    id?: number;
    title?: string | undefined;
    comment?: string | undefined;
    color?: ColorStatut;

    constructor(data?: IUpdateStatutCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.comment = _data["comment"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): UpdateStatutCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStatutCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["comment"] = this.comment;
        data["color"] = this.color;
        return data; 
    }
}

export interface IUpdateStatutCommand {
    id?: number;
    title?: string | undefined;
    comment?: string | undefined;
    color?: ColorStatut;
}

export class StatutStatByIdVm implements IStatutStatByIdVm {
    statutStat?: StatutStat;

    constructor(data?: IStatutStatByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statutStat = _data["statutStat"] ? StatutStat.fromJS(_data["statutStat"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StatutStatByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new StatutStatByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statutStat"] = this.statutStat ? this.statutStat.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStatutStatByIdVm {
    statutStat?: StatutStat;
}

export class StatutStat implements IStatutStat {
    evaluationsCount?: number;
    diffEvaluationsCount?: number;
    projectsCount?: number;
    diffProjectsCount?: number;
    actionPsCount?: number;
    diffActionPsCount?: number;
    contratsCount?: number;
    diffContratsCount?: number;

    constructor(data?: IStatutStat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.evaluationsCount = _data["evaluationsCount"];
            this.diffEvaluationsCount = _data["diffEvaluationsCount"];
            this.projectsCount = _data["projectsCount"];
            this.diffProjectsCount = _data["diffProjectsCount"];
            this.actionPsCount = _data["actionPsCount"];
            this.diffActionPsCount = _data["diffActionPsCount"];
            this.contratsCount = _data["contratsCount"];
            this.diffContratsCount = _data["diffContratsCount"];
        }
    }

    static fromJS(data: any): StatutStat {
        data = typeof data === 'object' ? data : {};
        let result = new StatutStat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["evaluationsCount"] = this.evaluationsCount;
        data["diffEvaluationsCount"] = this.diffEvaluationsCount;
        data["projectsCount"] = this.projectsCount;
        data["diffProjectsCount"] = this.diffProjectsCount;
        data["actionPsCount"] = this.actionPsCount;
        data["diffActionPsCount"] = this.diffActionPsCount;
        data["contratsCount"] = this.contratsCount;
        data["diffContratsCount"] = this.diffContratsCount;
        return data; 
    }
}

export interface IStatutStat {
    evaluationsCount?: number;
    diffEvaluationsCount?: number;
    projectsCount?: number;
    diffProjectsCount?: number;
    actionPsCount?: number;
    diffActionPsCount?: number;
    contratsCount?: number;
    diffContratsCount?: number;
}

export class StructuresVm implements IStructuresVm {
    structureDtos?: Structure[];

    constructor(data?: IStructuresVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["structureDtos"])) {
                this.structureDtos = [] as any;
                for (let item of _data["structureDtos"])
                    this.structureDtos!.push(Structure.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StructuresVm {
        data = typeof data === 'object' ? data : {};
        let result = new StructuresVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.structureDtos)) {
            data["structureDtos"] = [];
            for (let item of this.structureDtos)
                data["structureDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStructuresVm {
    structureDtos?: Structure[];
}

export class StructureByIdVm implements IStructureByIdVm {
    structureDto?: Structure;

    constructor(data?: IStructureByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.structureDto = _data["structureDto"] ? Structure.fromJS(_data["structureDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StructureByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new StructureByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["structureDto"] = this.structureDto ? this.structureDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStructureByIdVm {
    structureDto?: Structure;
}

export class CreateStructureCommand implements ICreateStructureCommand {
    startD?: Date;
    endD?: Date;
    parent?: number | undefined;
    title?: string | undefined;
    comment?: string | undefined;
    contrats?: number[];

    constructor(data?: ICreateStructureCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startD = _data["startD"] ? new Date(_data["startD"].toString()) : <any>undefined;
            this.endD = _data["endD"] ? new Date(_data["endD"].toString()) : <any>undefined;
            this.parent = _data["parent"];
            this.title = _data["title"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["contrats"])) {
                this.contrats = [] as any;
                for (let item of _data["contrats"])
                    this.contrats!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateStructureCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStructureCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startD"] = this.startD ? this.startD.toISOString() : <any>undefined;
        data["endD"] = this.endD ? this.endD.toISOString() : <any>undefined;
        data["parent"] = this.parent;
        data["title"] = this.title;
        data["comment"] = this.comment;
        if (Array.isArray(this.contrats)) {
            data["contrats"] = [];
            for (let item of this.contrats)
                data["contrats"].push(item);
        }
        return data; 
    }
}

export interface ICreateStructureCommand {
    startD?: Date;
    endD?: Date;
    parent?: number | undefined;
    title?: string | undefined;
    comment?: string | undefined;
    contrats?: number[];
}

export class UpdateStructureCommand implements IUpdateStructureCommand {
    id?: number;
    startD?: Date;
    endD?: Date;
    parent?: number | undefined;
    title?: string | undefined;
    comment?: string | undefined;
    contrats?: number[];

    constructor(data?: IUpdateStructureCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startD = _data["startD"] ? new Date(_data["startD"].toString()) : <any>undefined;
            this.endD = _data["endD"] ? new Date(_data["endD"].toString()) : <any>undefined;
            this.parent = _data["parent"];
            this.title = _data["title"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["contrats"])) {
                this.contrats = [] as any;
                for (let item of _data["contrats"])
                    this.contrats!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateStructureCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStructureCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startD"] = this.startD ? this.startD.toISOString() : <any>undefined;
        data["endD"] = this.endD ? this.endD.toISOString() : <any>undefined;
        data["parent"] = this.parent;
        data["title"] = this.title;
        data["comment"] = this.comment;
        if (Array.isArray(this.contrats)) {
            data["contrats"] = [];
            for (let item of this.contrats)
                data["contrats"].push(item);
        }
        return data; 
    }
}

export interface IUpdateStructureCommand {
    id?: number;
    startD?: Date;
    endD?: Date;
    parent?: number | undefined;
    title?: string | undefined;
    comment?: string | undefined;
    contrats?: number[];
}

export class TypeProjectsVm implements ITypeProjectsVm {
    typeProjectDtos?: TypeProject[];

    constructor(data?: ITypeProjectsVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["typeProjectDtos"])) {
                this.typeProjectDtos = [] as any;
                for (let item of _data["typeProjectDtos"])
                    this.typeProjectDtos!.push(TypeProject.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TypeProjectsVm {
        data = typeof data === 'object' ? data : {};
        let result = new TypeProjectsVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.typeProjectDtos)) {
            data["typeProjectDtos"] = [];
            for (let item of this.typeProjectDtos)
                data["typeProjectDtos"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITypeProjectsVm {
    typeProjectDtos?: TypeProject[];
}

export class TypeProjectByIdVm implements ITypeProjectByIdVm {
    typeProjectDto?: TypeProject;

    constructor(data?: ITypeProjectByIdVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeProjectDto = _data["typeProjectDto"] ? TypeProject.fromJS(_data["typeProjectDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TypeProjectByIdVm {
        data = typeof data === 'object' ? data : {};
        let result = new TypeProjectByIdVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeProjectDto"] = this.typeProjectDto ? this.typeProjectDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITypeProjectByIdVm {
    typeProjectDto?: TypeProject;
}

export class CreateTypeProjectCommand implements ICreateTypeProjectCommand {
    title?: string | undefined;
    codeTP?: string | undefined;
    comment?: string | undefined;

    constructor(data?: ICreateTypeProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.codeTP = _data["codeTP"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): CreateTypeProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTypeProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["codeTP"] = this.codeTP;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface ICreateTypeProjectCommand {
    title?: string | undefined;
    codeTP?: string | undefined;
    comment?: string | undefined;
}

export class UpdateTypeProjectCommand implements IUpdateTypeProjectCommand {
    id?: number;
    title?: string | undefined;
    codeTP?: string | undefined;
    comment?: string | undefined;

    constructor(data?: IUpdateTypeProjectCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.codeTP = _data["codeTP"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): UpdateTypeProjectCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTypeProjectCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["codeTP"] = this.codeTP;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IUpdateTypeProjectCommand {
    id?: number;
    title?: string | undefined;
    codeTP?: string | undefined;
    comment?: string | undefined;
}

export class TypeProjectsStatVm implements ITypeProjectsStatVm {
    typeProjectDto?: TypeProjectStat;

    constructor(data?: ITypeProjectsStatVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeProjectDto = _data["typeProjectDto"] ? TypeProjectStat.fromJS(_data["typeProjectDto"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TypeProjectsStatVm {
        data = typeof data === 'object' ? data : {};
        let result = new TypeProjectsStatVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeProjectDto"] = this.typeProjectDto ? this.typeProjectDto.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITypeProjectsStatVm {
    typeProjectDto?: TypeProjectStat;
}

export class TypeProjectStat implements ITypeProjectStat {
    typePCount?: number;
    diffETypePCount?: number;

    constructor(data?: ITypeProjectStat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typePCount = _data["typePCount"];
            this.diffETypePCount = _data["diffETypePCount"];
        }
    }

    static fromJS(data: any): TypeProjectStat {
        data = typeof data === 'object' ? data : {};
        let result = new TypeProjectStat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typePCount"] = this.typePCount;
        data["diffETypePCount"] = this.diffETypePCount;
        return data; 
    }
}

export interface ITypeProjectStat {
    typePCount?: number;
    diffETypePCount?: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}